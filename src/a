import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.ArrayList;
import java.util.List;

@Service
public class PoolApiService {

    private final RestTemplate restTemplate;
    private final Logger log = LoggerFactory.getLogger(PoolApiService.class);

    @Autowired
    public PoolApiService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    // This method gets the base information of the pools before filtering
    public ResponseEntity<List<Pool>> getFilteredPoolRepos() {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Accept", "application/json, text/plain, */*");
        HttpEntity<String> entity = new HttpEntity<>(headers);
        try {
            String apiUrl = "https://gaia-status-api.gaiacloud.jpmchase.net/api/v2/products/aap/pools";
            ResponseEntity<JsonNode> response = restTemplate.exchange(apiUrl, HttpMethod.GET, entity, JsonNode.class);
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                JsonNode responseBody = response.getBody();
                List<Pool> filteredPools = processResponse(responseBody.get("regions"));
                return ResponseEntity.ok(filteredPools);
            } else {
                log.error("Failed to get pool info: " + response.getStatusCode());
                return ResponseEntity.status(response.getStatusCode()).build();
            }
        } catch (Exception e) {
            log.error("Error retrieving the pool: " + e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    private List<Pool> processResponse(JsonNode regionsNode) {
        List<Pool> filteredPools = new ArrayList<>();
        try {
            if (regionsNode.isArray()) {
                for (JsonNode regionNode : regionsNode) {
                    String region = regionNode.get("region").asText();
                    ArrayNode poolsNode = (ArrayNode) regionNode.get("pools");

                    if (poolsNode != null) {
                        for (JsonNode poolNode : poolsNode) {
                            if ("strategic".equals(poolNode.get("dataCenterType").asText())) {
                                ArrayNode instancesNode = (ArrayNode) poolNode.get("instances");
                                for (JsonNode instanceNode : instancesNode) {
                                    if ("dev".equals(instanceNode.get("env").asText())) {
                                        Pool pool = createPool(poolNode, region, instanceNode);
                                        filteredPools.add(pool);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            log.error("Error processing response: " + e.getMessage(), e);
        }
        return filteredPools;
    }

    private Pool createPool(JsonNode poolNode, String region, JsonNode instanceNode) {
        Pool pool = new Pool();
        try {
            // Initialize a new Pool object
            pool.setRegion(region);
            pool.setPoolName(poolNode.get("pool").asText());
            pool.setDataCenterType(poolNode.get("dataCenterType").asText());
            pool.setAvgCpu(poolNode.get("avgCpu").asDouble());  // Set avgCpu in the Pool

            // Initialize a new Instance object
            Pool.Instance instance = new Pool.Instance();
            instance.setEnv(instanceNode.get("env").asText());

            // Set capacity details for the instance
            Pool.Instance.Capacity capacity = new Pool.Instance.Capacity();
            capacity.setAvailable(instanceNode.get("capacity").get("available").asInt());
            capacity.setMaxSlice(instanceNode.get("capacity").get("max_slice").asInt());
            capacity.setUsed(instanceNode.get("capacity").get("used").asInt());
            capacity.setTotal(instanceNode.get("capacity").get("total").asInt());
            instance.setCapacity(capacity);

            // Set next repave details for the instance if available
            if (instanceNode.has("repave") && instanceNode.get("repave").has("nextRepave")) {
                instance.setNextRepave(instanceNode.get("repave").get("nextRepave").asText());
            }

            // Assign the instance to the pool
            pool.setInstances(List.of(instance));
            
            log.info("Created pool: {}", pool.getPoolName());
        } catch (Exception e) {
            log.error("Error creating pool: " + e.getMessage(), e);
        }
        // Return the populated Pool object
        return pool;
    }
}
